""""
inlämning 1 uppgift 2
skapad 13/9
senaste uppdatering
14/9 - primtal_faktorer avbryts när n=1 (alla faktorer har dividerats bort)
27/9 - failsafe med specialfallen då användaren anger n<0 och n=1
29/9 - la till primtal_check samt dess användningar + gjorde steg 2 mer användar vänlig 

skapa ett program som utvärderar primtal


steg 1
p är listan som sparar alla faktorer
primtal_faktorer append:ar alla i som jämt delar n till p
primtal_check avgör om n har några faktorer, n har faktorer = True, n har INTE faktorer = False
for loop för att iterera alla möjliga faktorer
while loopen dividerar bort alla faktorer

steg 2
användaren får välja n
tar hänsyn till special fallen
kollar om p har några element för att avgöra om n har faktorer

steg 3
2 är redan i q då for-loopen bara itererar udda tal (för att spara tid)
lägger till j i listan q om primtal_check är False (dvs om j är ett primtal)



"""
#steg 1

def primtal_check(x):
    if x%2==0 and x/2 != 1:
        return True

    for i in range(3,int(x**0.5)+1,2):
        if x%i == 0:
            return True

    return False

p = []
def primtal_faktorer(x):
    for i in range(2,x):
        while x%i == 0:
           # print(x)
            p.append(i)
            x = x//i
        if x == 1:
            break


#steg 2
print("\n")
print("ange ett positivt heltal")
n = input("n = ")

if type(n) == str:
    print("ange ett positivt heltal \n")

else:
    if int(n) < 0:
        print("negativa tal kan inte vara inte primtal\n")

    elif int(n)==1:
        print("1 är inte ett primtal\n")

    else:
        if primtal_check(int(n)) == False:
            print(n, "är ett primtal\n")
        else:
            primtal_faktorer(int(n))
            print(n,"är inte ett primtal")
            print(n,"har primtalsfaktorerna",p,"\n")
            


# steg 3
q = [2]
for j in range(3, 101, 2):
    if primtal_check(j) == False:
        q.append(j)
print("alla primtal upp till 100")
print(q,"\n")