"""
------------------------------------------------------------------------------
POKER BOT
Skapad: 2025-11-21
Skapare: Lloyd Björnstedt

Ett program som ska fatta beslut åt användaren i spelet "Texas hold'em" baserat på korten som tilldelas

(Stegen 2-6 deklarerar funktioner)
STEG 1* - 
STEG 2  - 
STEG 3* - 
STEG 4* - 
STEG 5  -
STEG 6  - 

Mer information står vid respektive steg om det behövs.  
------------------------------------------------------------------------------
"""

# ------- STEG 1 -------

from itertools import combinations as comb
from collections import Counter
from functools import lru_cache as cache
import random
import pickle
import os



# ------- STEG 2 -------

# skapar en kortlek
def skapa_kortlek(kända_kort=None):
    # gör känd_kort till en lista eftersom mutable keyword är katastrof 
    if kända_kort is None:
        kända_kort = [] 

    färg = [1, 2, 3, 4] 
    
    # hjärter = 1    
    # spader = 2
    # klöver = 3
    # ruter = 4

    # skapar kortleken och tar bort reda kända kort
    lista = [(f, v) for f in färg for v in range(2, 15) if (f, v) not in kända_kort]

    return lista

# tar input från användaren
def kort_input(antal_kort:int, num_kort:int, lista:list):
    valör_num = {"knäckt":11, "dam":12, "kung":13, "ess":14}
    färg_num = {"hjärter":1, "h":1, "spader":2, "s":2, "klöver":3, "k":3, "ruter":4, "r":4}

    for i in range(antal_kort):  # antalet kort man ska dra
        while True:
            try:
            # .lower() få allting i små bokstäver, stip() ta bort blanksteg (början och slut)
                färg, valör = input(f"kort {i + num_kort}: ").lower().strip().split()
                if valör in valör_num:
                    nya_valör = valör_num[valör]
                else:
                    nya_valör = int(valör)
                
                nya_färg = färg_num[färg]
                break
            
            except (ValueError, KeyError): # ValueError om inte split, KeyError om inte i en av dict 
                pass
     
        tuple_kort = (nya_färg, nya_valör) # sparar kort som en tuple 
        print(tuple_kort)
        lista.append(tuple_kort)

    print(lista)        

  
# ------- STEG 3 -------
# funktioner för att avgöra styrkan på en 5-korts hand 
# par_triss_fyrtal_färg räknar förekomsten av en valör eller färg 
# stege avgör om alla valörer är i direkt följd 
# 
# hand_eval sätter ihop allt och ger ett numeriskt värde till varje hand 

# har par, tvåpar, triss, fyrtal eller färg ger funktionen True
def par_triss_fyrtal_färg(hand:list, antal:int, tvåpar=False) -> bool:
    hand_dict = Counter(hand)

    if tvåpar:
        antal_par = 0

        for kort in hand_dict.values():
            if kort == antal:
                antal_par += 1

        if antal_par == 2:  # count-funktionen har inte hänsyn till dubbletter
            return True

    else:
        for kort in hand_dict.values():
            if kort == antal:
                return True

    return False

# har stege ger funktionen True
def stege(hand:list) -> bool:
    stegen = 1  # sparar antalet kort i direkt följd

    # kort med index "i" är kortet = förra kortet+1
    for i in range(1, 5):
        if hand[i] == hand[i - 1] + 1:
            stegen += 1

    if stegen == 5:
        return True

    elif hand == [2, 3, 4, 5, 14]:  # specialfallet då ess är lägsta kortet i en stege
        return True

    return False

# bestämmer bästa kortet i kombinationen (tie-breaker)
def bästa_kort(hand:list, komb:str) -> int:
    # flera händer kan ha samma kombination och då vinner den som har bästa korten i kombinationen
    # den här funktionen ger 2-3 av handens bästa kort 

    temp_dict = Counter(hand) # key = valör, value = antalet av valören 
    no_dup_hand = [] # 
    poäng = 0

    for kort in hand:
        if kort not in no_dup_hand:
            no_dup_hand.append(kort)

    if komb == "stege": # stege ger de 3 bästa korten i handen (används mer än bara för stege)
        if hand == [2, 3, 4, 5, 14]:  # specialfall då ess = 1
            hand.remove(14)           # ess är inte det bästa kortet i detta fall

        return (hand[-1] * 10_000) + (hand[-2] * 100) + (hand[-3])

    elif komb == "kåk":
        for val, ant in temp_dict.items():
            if ant == 3: 
                poäng  += (val*10_000) # valör för triss * 10 000

            elif ant == 2: # par
                poäng  += (val*100) # valör för par * 100

        return poäng # eftersom triss trumfar par ger triss:en mer poäng 

    elif komb == "fyrtal":
        for val, ant in temp_dict.items():
            if ant == 4: 
                poäng  += (val * 10_000) # valör för fyrtal * 10 000

            elif ant == 1:
                poäng  += (val * 100) # högsta kortet * 100 

        return poäng 
    
    elif komb == "triss":
        for val, ant in temp_dict.items():
            if ant == 3:
                poäng  += (val * 10_000)
                no_dup_hand.remove(val) 

        return poäng  + (no_dup_hand[-1]*100) + no_dup_hand[-2]


    elif komb == "tvåpar":
        tvåpar = []
        for val, ant in temp_dict.items():
            if ant == 2:
                tvåpar.append(val)
                no_dup_hand.remove(val)

        sort_tvåpar = sorted(tvåpar) # sorterar par-valörerna för att det bästa paret ska ge mest poäng 
        return (sort_tvåpar[1] * 10_000) + (sort_tvåpar[0]*100) + no_dup_hand[0]

    elif komb == "par":
        for val, ant in temp_dict.items():
            if ant == 2:
                poäng += (val * 10_000)
                no_dup_hand.remove(val)

        return poäng + (no_dup_hand[-1] * 100) + (no_dup_hand[-2])

    return 0

# utvärderar hand med 5 kort
def hand_eval(hand:tuple):
    temp_valör = []
    temp_färg = []

    for kort in hand:
        färg, valör = kort

        temp_färg.append(färg)
        temp_valör.append(valör)

    sort_valör = sorted(temp_valör)

    # färgstege = 8
    if stege(sort_valör) and par_triss_fyrtal_färg(temp_färg, 5):
        return (8_000_000 + bästa_kort(sort_valör, "stege"))

    # fyrtal = 7
    elif par_triss_fyrtal_färg(sort_valör, 4):
        return (7_000_000 + bästa_kort(sort_valör, "fyrtal"))

    # kåk = 6
    elif par_triss_fyrtal_färg(sort_valör, 2) and par_triss_fyrtal_färg(sort_valör, 3):
        return (6_000_000 + bästa_kort(sort_valör, "kåk"))

    # färg = 5
    elif par_triss_fyrtal_färg(temp_färg, 5):
        return (5_000_000 + bästa_kort(sort_valör, "stege"))

    # stege = 4
    elif stege(sort_valör):
        return (4_000_000 + bästa_kort(sort_valör, "stege"))

    # triss = 3
    elif par_triss_fyrtal_färg(sort_valör, 3):
        return (3_000_000 + bästa_kort(sort_valör, "triss"))

    # tvåpar = 2
    elif par_triss_fyrtal_färg(sort_valör, 2, True):
        return (2_000_000 + bästa_kort(sort_valör, "tvåpar"))

    # par = 1
    elif par_triss_fyrtal_färg(sort_valör, 2):
        return (1_000_000 + bästa_kort(sort_valör, "par"))

    # högt kort/inget = 0
    else:
        return (0 + bästa_kort(sort_valör, "stege"))



# ------- STEG 4 -------

# skapar hash-nyckel för en 5-kort hand
def hash_funktion(hand:tuple) -> int:
    primtal = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41]
    prim_key = 1
    flush = True
    färg = hand[0][0]

    for f, v in hand:
        prim_key *= primtal[v - 2]
        if f != färg:
            flush = False

    if flush:
        prim_key *= 43

    return prim_key

# letar genom hash-nycklar och ger hands värde
def hash_get(hand:tuple) -> int:
    key = hash_funktion(hand)
    return hash_lookup.get(key, 0)

@cache(maxsize=40_000)
def hash_eval_7(hand_7:tuple) -> int:
    return max(hash_get(hand_5) for hand_5 in comb(hand_7,5))

# bestämmer sannolikhet för vinst
def simulering(cc:list, hk:list, iter:int, spelare=1,) -> float:
    win = tie = 0
    kortlek = skapa_kortlek(hk + cc)
    kort_kvar = 5 - len(cc)  # antalet kort som ska ut på bordet

    for __ in range(iter):
        behövs = kort_kvar + (spelare * 2)
        urval_kort = random.sample(kortlek, behövs)
        bord = cc + urval_kort[:kort_kvar]
        bäst_motsåndare = 0

        jag_poäng = hash_eval_7(tuple(sorted(hk + bord)))

        for i in range(spelare):
            start = kort_kvar + (i*2)
            opp_hk = urval_kort[start : start+2]
            motståndare_poäng = hash_eval_7(tuple(sorted(opp_hk + bord)))

            if motståndare_poäng > bäst_motsåndare:
                bäst_motsåndare = motståndare_poäng

        if bäst_motsåndare < jag_poäng :
            win += 1

        elif bäst_motsåndare == jag_poäng :
            tie += 1

    equity = (win + (0.5 * tie)) / iter

    #print(len(kortlek), iter)
    print(f"\nwin: {win:<7} tie: {tie:<7} lose: {(iter) - (win + tie):<7} %win: {100 * equity:.2f}")
    return equity



# ------- STEG 5 -------

# om pickle-filen inte finns skapas en 
def skapa_pickle_fil() -> dict:
    kl = skapa_kortlek()
    ny_lookup = {}

    for hand in comb(kl, 5):
        hash_hand = hash_funktion(hand)
        if hash_hand not in ny_lookup:
            ny_lookup[hash_hand] = hand_eval(hand)

    return ny_lookup

# laddar pickle-filen och fyller hash_lookup 
def ladda_pickle_fil() -> dict:
    cache_fil = 'poker_hash_cache.pkl'

    if os.path.exists(cache_fil):
        print("Laddar pickle-fil")
        with open(cache_fil, 'rb') as f:
            return pickle.load(f)

    else:
        print("Ingen pickle-fil hittades")
        hash_dict = skapa_pickle_fil()
        with open(cache_fil, 'wb') as f:
            pickle.dump(hash_dict, f)
        print("Hash map genererad och sparad!")
        return hash_dict

# säger vad spelaren ska göra
def beslut(win_chans:float) -> int:
    pot = eval(input(f"pot: "))
    print(f"= {pot}")
    call = int(input(f"syna: "))
    
    odds = call / (pot + call)
    ev = (win_chans*pot) - ((1-win_chans)*call)

    if win_chans >= odds:
        print("\ncall")
        print(f"behövs: {100 * odds:.2f} | jag har: {100 * win_chans:.2f}   ev = {ev:.2f}")
    else:
        print("\nfold")
        print(f"behövs: {100 * odds:.2f} | jag har: {100 * win_chans:.2f}   ev = {ev:.2f}")
    
    return call

# själva spelrundan
def spelrunda() -> None:
    hålkort = []
    community_cards = []
    info = {"Pre-flop": (2, 1, hålkort), "Flop": (3, 3, community_cards), "Turn": (1, 6, community_cards), "River": (1, 7, community_cards)}

    antal_spelare = int(input(f"antal spelare (exkl. du sjäv): "))
    #start_marker = int(input(f"antal marker vid start: "))

    for runda, kort in info.items():
        kort_antal, kort_num, kort_lista = kort

        print(f"\n------------------------------------------\n{runda}\n\n")
        kort_input(kort_antal, kort_num, kort_lista)

        #print("\n")
        res_sim = simulering(community_cards, hålkort, 20_000, spelare=antal_spelare)
        print(" ")
        #bet = beslut(res_sim)
        #start_marker -= bet

    hash_eval_7.cache_clear()


# ------- STEG 6 -------

def main() -> None:
    if not hash_lookup:
        print(f"VARNING: hash_lookup är tom\n------------------------------------------\n")
    else:
        print(f"Allting ser bra ut\n------------------------------------------\n")

    spelrunda()

if __name__ == "__main__":
    hash_lookup = ladda_pickle_fil() # global variabel (inte optimalt men gör livet MYCKET enklare)
    main()



"""
a = []
kort_input(3,1,a)


while True:
    try:
        x = int(input(": "))
        break
    except (NameError, ValueError):
        pass
"""


"""
import time  # start = time.perf_counter() # stop = time.perf_counter()


hk = [(1, 14), (2, 14)]

cc1 = []
cc2 = [(3, 2), (2, 2), (4, 2)]
cc3 = [(3, 2), (2, 2), (4, 2), (3, 6)]
cc4 = [(3, 2), (2, 2), (4, 2), (3, 6), (4, 7)]

temp = [cc1, cc2, cc3, cc4]

# h = 1    
# s = 2
# k = 3
# r = 4

for i in temp:
    start = time.perf_counter()
    simulering(i, hk, 30_000, spelare=2)
    print(hash_eval_7.cache_info())
    stop = time.perf_counter()
    print(f"{stop - start:.4f}\n")
"""
