"""
POKER BOT
skapad: 21/11/2025
skapare: Lloyd Björnstedt

Ett program som ska fatta beslut åt användaren i spelet "Texas hold'em" baserat på korten som tilldelas

Stegen 1-4 deklarerar funktioner
steg 1 - skapa kortlek + input från användaren och sparar datan + importerar itertools
steg 2 - kunna utvärdera olika kombinatioer
steg 3 - funktioner från steg 2 för att rangordna alla kombinationer
steg 4 - själva spelrundan
steg 5 - exikverar
"""

from itertools import combinations as comb
import random

import time
# start = time.perf_counter()
# stop = time.perf_counter()

# skapar en kortlek
def skapa_kortlek(kända_kort):
    valör = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14"]  # alla valörer som tal
    färg = ["s", "k", "r", "h"]  # spader, klöver, ruter, hjärter (ÄNDRA SEN)
    lista = []

    for f in färg:
        for v in valör:
            lista.append(f + " " + v)

    for kort in kända_kort:
        lista.remove((kort))

    return lista

# tar input från användaren
def kort_input(antal, num_kort, lista):
    for i in range(antal):  # antalet kort man ska dra
        färg, valör = input(f"kort {i + num_kort}: ").split(" ")  # Note to self: ValueError om inte split, (" ") för att garantera split

        # ger numeriskt värde till klädda kort
        if valör == "knäckt":
            valör = "11"

        elif valör == "dam":
            valör = "12"

        elif valör == "kung":
            valör = "13"

        elif valör == "ess":
            valör = "14"

        lista.append(färg + " " + valör)  # färg + valör = hela kortet



# bestämmer bästa kortet i kombinationen
def bästa_kort(hand, stege=False, div=100, antal=0):
    if stege:
        if sorted(hand) == [2, 3, 4, 5, 14]:
            return 0.05
        else:
            return max(hand)/100

    else:
        for kort in hand:
            if hand.count(kort) == antal:
                return kort/div

# har par, tvåpar, triss, fyrtal eller färg -> True
def par_triss_fyrtal_färg(antal, hand, tvåpar=False):
    if tvåpar:
        antal_par = 0

        for kort in hand:
            if hand.count(kort) == 2:
                antal_par += 1

        if antal_par == 4:  # count-funktionen har inte hänsyn till dubbletter
            return True

    else:
        for kort in hand:
            if hand.count(kort) == antal:
                return True

# har stege -> True
def stege(hand):
    stegen = 1  # sparar antalet kort i direkt följd

    # kort med index "i" är kortet = förra kortet+1
    for i in range(1, len(hand)):
        if sorted(hand)[i] == sorted(hand)[i - 1] + 1:
            stegen += 1
        else:
            stegen = 1

    if stegen == 5:
        return True

    elif sorted(hand) == [2, 3, 4, 5, 14]:  # specialfallet då ess är lägsta kortet i en stege
        return True



# utvärderar hand med 5 kort
def hand_eval(hand):
    temp_valör = []
    temp_färg = []

    for kort in hand:
        färg, valör = kort.split(" ")

        temp_färg.append(färg)
        temp_valör.append(int(valör))

    # färgstege = 8
    if stege(temp_valör) and par_triss_fyrtal_färg(5, temp_färg):
        return (8 + bästa_kort(temp_valör, stege=True))

    # fyrtal = 7
    elif par_triss_fyrtal_färg(4, temp_valör, False):
        return (7 + bästa_kort(temp_valör, antal=4))

    # kåk = 6
    elif par_triss_fyrtal_färg(2, temp_valör) and par_triss_fyrtal_färg(3, temp_valör):
        return (6 + bästa_kort(temp_valör, antal=3) + bästa_kort(temp_valör, antal=2, div=10000))

    # färg = 5
    elif par_triss_fyrtal_färg(5, temp_färg):
        return (5 + bästa_kort(temp_valör, stege=True))

    # stege = 4
    elif stege(temp_valör):
        return (4 + bästa_kort(temp_valör, stege=True))

    # triss = 3
    elif par_triss_fyrtal_färg(3, temp_valör):
        return (3 + bästa_kort(temp_valör, antal=3))

    # tvåpar = 2
    elif par_triss_fyrtal_färg(2, temp_valör, True):
        return (2 + bästa_kort(sorted(temp_valör)[::-1], antal=2) + bästa_kort(sorted(temp_valör), antal=2, div=10000))

    # par = 1
    elif par_triss_fyrtal_färg(2, temp_valör):
        return (1 + bästa_kort(temp_valör, antal=2))

    # högt kort/inget = 0
    else:
        return (0 + bästa_kort(temp_valör, stege=True))

# bestämmer sannolikhet för vinst
def simulering(cc, hk, iter): 
    win = tie = 0
    kortlek = skapa_kortlek(hk + cc)
    x = 5 - len(cc)                     # antalet kort som ska ut på bordet 

    for __ in range(iter):
        y = random.sample(kortlek, x+2)
        bord_nu = cc + y[:x]
        opp_hk = y[x:]

        p1 = max([hand_eval(i) for i in list(comb(hk+bord_nu,5))])
        p2 = max([hand_eval(i) for i in list(comb(opp_hk+bord_nu,5))])
        
        if p2 < p1:
            win += 1

        elif p2 == p1:
            tie += 1

    equity = (win + (0.5 * tie)) / iter

    print(len(kortlek), iter)
    print(f"win: {win:<7} tie: {tie:<7} lose: {(iter)-(win+tie):<7} %win: {100*equity:.2f}")
    #return equity

# säger vad spelaren ska göra
def beslut(win_chans):
    call = int(input(f"syna: "))
    pot = int(input(f"pot: "))

    odds = (call/(pot+call))*100

    if win_chans >= odds:
        print("call")
        print(f"{odds:.2f} | {win_chans}")
    else:
        print("fold")
        print(f"{odds} | {win_chans}")

# själva spelrundan
def spelrunda():
    info = {"Pre-flop": 2, "Flop": 3, "Turn": 1, "River": 1}

    hålkort = []
    community_cards = []

    for runda, antal_kort in info.items():
        print(f"\n------------------------------------------\n{runda}\n\n")

        if runda == "Pre-flop":
            kort_input(antal_kort, len(hålkort + community_cards) + 1, hålkort)

        else:
            kort_input(antal_kort, len(hålkort + community_cards) + 1, community_cards)

        x = simulering(community_cards, hålkort, 1000)
        beslut(x)


#spelrunda()




hk = ["k 4", "s 3"]

cc1 = []
cc2 = ["s 11", "h 9", "s 4"]
cc3 = ["s 11", "h 9", "s 4", "r 12"]
cc4 = ["s 11", "h 9", "s 4", "r 12", "s 13"]

temp = [cc1, cc2, cc3, cc4]

for i in temp:
    start = time.perf_counter()
    simulering(i, hk, 1000)
    stop = time.perf_counter()
    print(f"{stop-start:.5f}\n")
    

    