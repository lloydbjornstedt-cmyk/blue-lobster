
# steg 1

from itertools import combinations


# berättar vad ens bästa hand är (TILLFÄLLIG)
def hand(rang:list) -> str:
    bäst = max(rang) # tar fram den bästa handen

    if bäst == 8:
        return "färgstege"

    elif bäst == 7:
        return "fyrtal"

    elif bäst == 6:
        return "kåk"

    elif bäst == 5:
        return "färg"

    elif bäst == 4:
        return "stege"

    elif bäst == 3:
        return "triss"

    elif bäst == 2:
        return "tvåpar"

    elif bäst == 1:
        return "par"

    elif bäst == 0:
        return f"högt kort"



# steg 2
def skapa_kortlek(lista:list[None]) -> list[str]:
    valör = [2,3,4,5,6,7,8,9,10,11,12,13,14]    # alla valörer som tal
    färg = ["s","k","r","h"]                    # spader, klöver, ruter, hjärter (ÄNDRA SEN)

    for f in färg:
        for v in valör:
            lista.append(f+" "+str(v))   

    return lista

def kort_input(antal:int, numret:int, lista:list[str]) -> None:
    for i in range(antal):                                    # antalet kort man ska dra
        färg, valör = input(f"kort {i+numret}: ").split(" ")  # Note to self: ValueError om inte split, (" ") för att garantera split

         # ger numeriskt värde till klädda kort
        if valör == "knäckt":
            valör = 11

        elif valör == "dam":
            valör = 12

        elif valör == "kung":
            valör = 13

        elif valör == "ess":   
            valör = 14

        # färg + valör tillsammans
        lista.append(färg + " " + str(valör))
    


# har par, tvåpar, triss, fyrtal eller färg = True
def par_triss_fyrtal_färg(antal:int, hand:list[str], tvåpar:bool) -> bool:
    if tvåpar:
        antal_par = 0

        for i in hand:
            if hand.count(i) == 2:
                antal_par += 1

        if antal_par == 4: # count-funktionen har inte hänsyn till dubbletter
            return True
        
    else:
        for i in hand:
            if hand.count(i) == antal:
                return True

# har stege = True
def stege(hand:list[str]) -> bool:
    stegen = 1   # sparar antalet kort i direkt följd

    # ett kort med index "i" är kortet = förra kortet+1 
    for i in range(1,len(hand)):
        if sorted(hand)[i] == sorted(hand)[i-1] + 1:
           stegen += 1
        else:
            stegen = 1

    if stegen == 5:
        return True
    
    elif sorted(hand) == [2,3,4,5,14]: # specialfallet då ess är lägsta kortet i en stege
        return True



# ger ett numeriskt värde till hållkort kombinationer
def pre_flop_eval(hand:tuple[str], rang:list) -> None:
    temp_valör = []
    temp_färg = []

    for kort in hand:
        färg, valör = kort.split(" ")

        temp_färg.append(färg)
        temp_valör.append(int(valör))

    #if all(temp_valör) and all(temp_färg) and temp_färg[0]>9:
        #rang.append(3)
        #return
    
    #if par_triss_fyrtal_färg(2,temp_valör,False) and all(temp_)
        #rang.append(2)
        #return
    
    if par_triss_fyrtal_färg(2,temp_valör,False):
        rang.append(1)
        return
    
    else:
        rang.append(0)
        return 

# ger numeriskt värde till alla 5 kort kombinationer (0-8)
def hand_eval(hand:tuple[str], rang:list[int]) -> None:
    temp_valör = []
    temp_färg = []

    for kort in hand:
        färg, valör = kort.split(" ")

        temp_färg.append(färg)
        temp_valör.append(int(valör))

    # färgstege = 8
    if stege(temp_valör) and par_triss_fyrtal_färg(5,temp_färg,False):
        rang.append(8)
        return 

    # fyrtal = 7
    elif par_triss_fyrtal_färg(4, temp_valör,False):
        rang.append(7)
        return 

    # kåk = 6
    elif par_triss_fyrtal_färg(2, temp_valör,False) and par_triss_fyrtal_färg(3, temp_valör,False):
        rang.append(6)
        return 

    # färg = 5
    elif par_triss_fyrtal_färg(5,temp_färg,False):
        rang.append(5)
        return 

    # stege = 4
    elif stege(temp_valör):
        rang.append(4)
        return 

    # triss = 3
    elif par_triss_fyrtal_färg(3, temp_valör,False):
        rang.append(3)
        return 

    # tvåpar = 2
    elif par_triss_fyrtal_färg(2, temp_valör,True):
        rang.append(2)
        return 

    # par = 1
    elif par_triss_fyrtal_färg(2, temp_valör,False):
        rang.append(1)
        return 

    # högt kort/inget = 0
    else:
        rang.append(0)
        return  



# själva spelet
def simulation(pf:bool, cc:list[str], hk:list[str], rang:list[int]) -> str:
    sim_rang = []
    kortlek = []   
    win = 0
    tie = 0 
    lose = 0
    skapa_kortlek(kortlek)

    for kort in cc+hk:
        if kort in kortlek:
            kortlek.remove(kort)
    
    möjliga_hk = list(combinations(kortlek,2)) # -2 * antal spelare

    for hand in möjliga_hk:
        sim_rang.clear()

        if pf == True:
            for j in list(combinations(list(hand),2)):
                pre_flop_eval(j,sim_rang)
        else:
            for j in list(combinations(list(hand)+cc,5)):
                hand_eval(j,sim_rang)

        if max(sim_rang) < max(rang):
            win += 1

        elif max(sim_rang) == max(rang):
            tie += 1
        
        else:
            lose += 1
        

    print(win+tie+lose)
    return f"win: {win:<10} tie: {tie:<10} lose: {lose:<10} prob win: {(win/len(möjliga_hk))*100}%" #temp 

def spelrunda() -> None:
    info_runda = ["Pre-flop","Flop","Turn","River",2,3,1,1,3,6,7]  # vilken runda (0-3) + antalet kort man drar (4-7) + numret på kortet (7-10)
    hålkort = []
    community_card = []
    pf_rang = []
    hand_rang = []

    for i in range(4):
        print("\n------------------------------------------")
        print(f"{info_runda[i]}\n\n")

        if i == 0: # pre-flop utvärderas på eget sätt  
            kort_input(info_runda[i+4],info_runda[i+7],hålkort) 
            for hands in list(combinations(hålkort,2)):
                pre_flop_eval(hands,pf_rang)

            print(f"\n{hand(pf_rang)}") # temp
            print(f"\n{simulation(True,community_card,hålkort,pf_rang)}") #temp

        else:
            kort_input(info_runda[i+4],info_runda[i+7],community_card)
            for hands in list(combinations(hålkort+community_card,5)):
                hand_eval(hands,hand_rang)

            print(f"\n{hand(hand_rang)}")   # temp
            print(f"\n{simulation(False,community_card,hålkort,hand_rang)}") # temp

        print(f"\n{len(hand_rang)+len(pf_rang)}") # temp
        

# steg 3

#spelrunda()




def simulation2(runda:str, cc:list[str], hk:list[str], rang:list[int]) -> str:
    sim_rang = []
    kortlek = []   
    win = 0
    tie = 0 
    lose = 0
    skapa_kortlek(kortlek)

    for kort in cc+hk:
        if kort in kortlek:
            kortlek.remove(kort)

    #sim_rang.clear()

    if runda == "Pre-Flop":
        for hand in list(combinations(kortlek,3)):
            hand_eval(list(hand)+cc,sim_rang)

    elif runda == "Flop":
        for i in list(combinations(kortlek,1)):
            for hand in list(combinations(hk+cc+list(i),5)):
                hand_eval(hand,sim_rang)

    elif runda == "Turn":
        for i in list(combinations(kortlek,1)):
            for hand in list(combinations(hk+cc+list(i),5)):
                hand_eval(hand,sim_rang)

    else:
        pass

    for i in sim_rang:
        if i < max(rang):
            win += 1

        elif i == max(rang):
            tie += 1

        else:
            lose += 1
        

    print(win+tie+lose)
    return f"win: {win:<10} tie: {tie:<10} lose: {lose:<10} prob win: {(win/(win+tie+lose))*100}%" #temp 


hk = ["s 14","k 14"]

cc1 = []
cc2 = ["k 10","h 2","h 7"]
cc3 = ["k 10","h 2","h 7","r 11"]
cc4 = ["k 10","h 2","h 7","r 11","r 4"]

y1 = []
y2 = []
y3 = []
y4 = []

x1 = list(combinations(hk+cc1,2))
for i in x1:
    hand_eval(i,y1)

x2 = list(combinations(hk+cc1,2))
for i in x2:
    hand_eval(i,y2)

x3 = list(combinations(hk+cc1,2))
for i in x3:
    hand_eval(i,y3)

x4 = list(combinations(hk+cc1,2))
for i in x4:
    hand_eval(i,y4)


print(simulation2("Pre-Flop",cc1,hk,y1))
print(simulation2("Flop",cc2,hk,y2))
print(simulation2("Turn",cc3,hk,y3))
#print(simulation2("River",cc4,hk,y4))